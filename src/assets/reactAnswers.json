{
  "beginner": [
    {
      "question": "What is React?",
      "answer": "React is a declarative, component-based JavaScript library for building interactive UIs.",
      "bullets": [
        "Component-based architecture",
        "State-driven rendering",
        "Virtual DOM for efficient updates",
        "Just the view layer, highly flexible"
      ]
    },
    {
      "question": "What is JSX?",
      "answer": "JSX is a syntax extension that lets you write HTML-like code directly inside JavaScript.",
      "bullets": [
        "Compiles to React.createElement()",
        "Improves readability and structure",
        "Optional but widely used"
      ]
    },
    {
      "question": "What are props?",
      "answer": "Props are read-only inputs passed from parent to child components.",
      "bullets": [
        "Immutable",
        "Enable one-way data flow",
        "Trigger re-renders when changed"
      ]
    },
    {
      "question": "What is state?",
      "answer": "State is internal component data that can change over time and triggers UI updates.",
      "bullets": [
        "Mutable",
        "Owned by component",
        "Drives re-renders"
      ]
    },
    {
      "question": "What is the Virtual DOM?",
      "answer": "The Virtual DOM is an in-memory representation of the real DOM that React uses to compute efficient updates.",
      "bullets": [
        "State changes trigger virtual DOM updates",
        "React diffs old vs new trees",
        "Only minimal DOM operations applied"
      ]
    },
    {
      "question": "How do you create a component in React?",
      "answer": "By defining a function or class that returns JSX.",
      "bullets": [
        "Function components preferred",
        "Hooks enable state and effects"
      ]
    },
    {
      "question": "What is the difference between functional vs class components?",
      "answer": "Functional components are plain functions that use hooks; class components use lifecycle methods and `this`.",
      "bullets": [
        "Hooks are simpler and more composable",
        "Functional components avoid `this` binding"
      ]
    }
  ],

  "intermediate": [
    {
      "question": "How does reconciliation work in React?",
      "answer": "React compares two virtual DOM trees and applies the minimal set of changes to the real DOM.",
      "bullets": [
        "Shallow diffing",
        "Replace subtree if element type changes",
        "Keys help track identity in lists"
      ]
    },
    {
      "question": "Why is direct DOM manipulation discouraged?",
      "answer": "React manages the DOM through its reconciliation process, so manual edits can break consistency.",
      "bullets": [
        "DOM updates are slow",
        "Imperative updates should use refs inside useEffect",
        "React expects to own the DOM"
      ]
    },
    {
      "question": "What is useEffect?",
      "answer": "useEffect runs side effects after render and optionally cleans them up.",
      "bullets": [
        "Used for API calls, subscriptions, timers",
        "Cleanup prevents memory leaks",
        "Dependency array controls when it runs"
      ]
    },
    {
      "question": "What is useMemo used for?",
      "answer": "useMemo memoizes expensive calculations to avoid re-running them unnecessarily.",
      "bullets": [
        "Performance optimization",
        "Only recomputes when dependencies change"
      ]
    },
    {
      "question": "What is useCallback used for?",
      "answer": "useCallback memoizes function references to prevent unnecessary child re-renders.",
      "bullets": [
        "Useful with React.memo",
        "Stabilizes function identities"
      ]
    },
    {
      "question": "How would you optimize a React application that re-renders too often?",
      "answer": "Use memoization, move state down, avoid inline values, and profile the render tree.",
      "bullets": [
        "React.memo",
        "useCallback/useMemo",
        "Split large components",
        "Virtualize long lists",
        "Avoid heavy work in render"
      ]
    },
    {
      "question": "What are controlled vs uncontrolled components?",
      "answer": "Controlled inputs derive their value from React state; uncontrolled use refs.",
      "bullets": [
        "Controlled: predictable, easy validation",
        "Uncontrolled: less state, simpler"
      ]
    },
    {
      "question": "How does context work?",
      "answer": "Context allows passing data through the component tree without prop drilling.",
      "bullets": [
        "Useful for theme, auth, settings",
        "Overuse causes excessive re-renders"
      ]
    },
    {
      "question": "Explain the event system in React.",
      "answer": "React uses a synthetic event system that wraps native events for consistency.",
      "bullets": [
        "Cross-browser normalized",
        "Events are pooled and batched",
        "Improves performance"
      ]
    }
  ],

  "advanced": [
    {
      "question": "What is React Fiber?",
      "answer": "React Fiber is the reconciliation engine enabling incremental, interruptible rendering.",
      "bullets": [
        "Supports async rendering",
        "Better scheduling and prioritization",
        "Improves UI responsiveness"
      ]
    },
    {
      "question": "Explain how React batching works.",
      "answer": "React batches multiple state updates into a single render for efficiency.",
      "bullets": [
        "setState is asynchronous",
        "Modern React batches across async boundaries",
        "Reduces DOM thrashing"
      ]
    },
    {
      "question": "How do you handle large lists in React?",
      "answer": "Use virtualization so only visible items render at once.",
      "bullets": [
        "react-window",
        "react-virtualized",
        "Avoids huge DOM trees"
      ]
    },
    {
      "question": "Explain hydration in SSR.",
      "answer": "Hydration attaches React listeners to already-rendered HTML from the server.",
      "bullets": [
        "Enables fast first paint",
        "Client takes over after hydration"
      ]
    },
    {
      "question": "Explain how React prioritizes updates.",
      "answer": "React Fiber assigns priority levels and schedules rendering accordingly.",
      "bullets": [
        "User input > animations > data updates > background tasks"
      ]
    },
    {
      "question": "How would you debug a React performance issue?",
      "answer": "Profile renders, inspect wasted renders, and break down slow components.",
      "bullets": [
        "React DevTools Profiler",
        "Highlight updates",
        "Check dependency arrays",
        "Memoize expensive work"
      ]
    },
    {
      "question": "How does React differ from frameworks like Angular at scale?",
      "answer": "React favors composition and lightweight primitives; Angular is monolithic and DI-driven.",
      "bullets": [
        "React scales via patterns, state mgmt, context, hooks",
        "Angular has built-in structure, modules, DI"
      ]
    },
    {
      "question": "Explain how React handles concurrency.",
      "answer": "React concurrent mode (via Fiber) allows interruptible rendering and better user responsiveness.",
      "bullets": [
        "Splits rendering into units of work",
        "Pauses and resumes rendering",
        "Prioritizes urgent updates"
      ]
    }
  ],
  "amazon_specific": [
    {
      "question": "Explain a time you optimized a React application's performance.",
      "bullets": [
        "Identify the bottleneck (slow renders, large lists, unnecessary re-renders).",
        "Explain why React was re-rendering (state structure, prop identity, context usage).",
        "Show what tools you used (React Profiler, performance tab).",
        "Describe the optimization technique (memoization, virtualization, splitting state).",
        "End with measurable results."
      ],
      "example_answer": "In one project our page was lagging every time users expanded a large table. Profiling showed the entire component tree was re-rendering because the parent stored too much global state and passed unstable inline callbacks to children. I localized state into smaller components, memoized child rows with React.memo, and wrapped expensive callbacks with useCallback. For large datasets, I added react-window to virtualize the list. This reduced render time from ~180ms to under 20ms and eliminated noticeable UI lag. Amazon interviewers want to hear that you diagnosed the issue, understood why React was re-rendering, and applied targeted optimizations."
    },
    {
      "question": "How would you design a reusable component system?",
      "bullets": [
        "Define clear component boundaries and APIs.",
        "Separate presentational and logical layers.",
        "Use props for configuration; avoid hard-coded logic.",
        "Ensure accessibility is built in (labels, aria, keyboard nav).",
        "Make style overrides predictable (className, style props).",
        "Add tests to guarantee behavior across use cases."
      ],
      "example_answer": "A strong reusable component system starts with clear boundaries: each component handles one responsibility and exposes a simple, predictable API. For example, a reusable Button may accept size, variant, disabled, and onClick props, but should not contain business logic. I separate UI from logic using custom hooks where appropriate, which also improves testability. To ensure accessibility, I implement proper aria attributes and full keyboard support in the base component so downstream teams don't need to reinvent it. Finally, I allow teams to override styles via className or style props while preserving a consistent internal structure. This approach scales well in large organizations like Amazon where multiple teams share UI primitives."
    },
    {
      "question": "How would you ensure accessibility in a React application?",
      "bullets": [
        "Use semantic HTML first.",
        "Implement full keyboard navigation.",
        "Use proper aria attributes only when needed.",
        "Ensure color contrast meets WCAG standards.",
        "Test with screen readers and automated tools.",
        "Design components so accessibility is built-in."
      ],
      "example_answer": "I start with semantic HTML elements like <button>, <nav>, and <label> because they provide built-in screen reader and keyboard support. For interactive components, I ensure complete keyboard accessibility including focus management and escape flows. When semantics aren't enough, I add aria-label, aria-describedby, or role attributes. I verify color contrast using WCAG AA standards and run automated checks using tools like axe or Lighthouse. In more complex flows, I test with VoiceOver or NVDA to ensure dynamic updates are properly announced. At Amazon scale, I also push accessibility concerns into reusable components so every product downstream gets accessibility by default."
    },
    {
      "question": "How do you prevent unnecessary re-renders in React?",
      "bullets": [
        "Use React.memo for pure child components.",
        "useCallback to stabilize function references.",
        "useMemo to avoid expensive recalculations.",
        "Move state closer to where it is used.",
        "Avoid passing new objects/arrays inline.",
        "Be careful with context because it re-renders all consumers."
      ],
      "example_answer": "To prevent unnecessary re-renders, I start by analyzing which components rely on which pieces of state. If a parent holds too much state, children will re-render even when their data hasn't changed, so I move state closer to the components that actually use it. I wrap pure child components in React.memo and use useCallback to stabilize function props. For expensive computations, I use useMemo so they're not recalculated on every render. I also avoid inline object literals or arrays because they create new references each render. When using context, I either split it into multiple providers or use selectors to avoid re-rendering the entire subtree. This combination keeps the UI responsive and the render tree efficient."
    },
    {
      "question": "How would you architect a large-scale React application?",
      "bullets": [
        "Use a modular, feature-based folder structure.",
        "Build reusable component libraries.",
        "Separate UI, business logic, and data fetching.",
        "Use state management wisely (Redux, Zustand, context, RTK).",
        "Implement code splitting and lazy loading.",
        "Provide consistent error boundaries.",
        "Have a clear API layer abstraction.",
        "Include accessibility and testing in the core architecture."
      ],
      "example_answer": "For a large-scale React app like those at Amazon, I start with a feature-based architecture where each domain (Cart, Search, Profile) has its own components, hooks, and tests. I keep UI components pure and stateless, moving business logic into custom hooks or dedicated services to improve maintainability. Shared components go into a design system library to ensure consistency across teams. For global state, I prefer Redux Toolkit or Zustand depending on complexity, while local UI state stays inside components. I add lazy loading for routes and expensive components to reduce bundle size. A unified API layer abstracts fetch logic and provides error handling and caching. Finally, every feature includes accessibility and test coverage so scaling the codebase remains safe and predictable."
    }
  ]
}
